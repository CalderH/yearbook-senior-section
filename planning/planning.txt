okay

time to plan this for the long term

the program needs to be independent of the year. should be something that you can apply one year after the other, just to files in different folders.
keep the code in one folder. the different years go in their own folders

should be able to setup/customize it — where is each type of file stored, what is everything called
but also not have to worry about everything. if you don’t enter any setting, there is a default.

There should be a command that sets up the file system/database/etc in a given directory (?)



It should also be usable by other things in the yearbook — not just for the senior section (although most useful for that)
mainly I’m thinking about the athletics section. Get names straight





- When possible, collect information from students directly
- When collecting our own data, format the questions in a way that reduces the likelihood of erroneous answers
- When using others’ data, choose sources that are most likely to be trustworthy
- Check multiple sources against each other





hmm

I see 2 possible ways to store changes/versions… I’m kind of liking the more complicated one

Solution 1 (what I used last year):
Store many complete versions of the whole database. You can always just open any of the older files to see how it was in an older version. Create a new version for every significant change.

Solution 2:
Have one file that contains the complete history of the database: the initial data, and then all changes in order of execution along with times and commit messages. Then have a program that compiles that into a file representing the current state of the data, or the data at any other time. If you are at the working version and make a change, you can commit it and then the change goes to the file.


Advantages:
the working data file is always the same, has the same name
uses less space
easier to store small changes and get the status at any point

Disadvantages:
basically turns into small-scale Git

how could this be done in a way that is user-friendly?
in a way it’s actually more user-friendly. You don’t have to keep manually creating copies. You just edit the file and occasionally enter a commit message. That’s it.






how does the object-based API work?

there should be a database object, which you get other things from

a database is essentially a set of *record versions*. Can take a vertical slice through these to get the set of record versions at any given time: a snapshot of the DB at that time/commit. Or can take a horizontal slice to get the version history of an individual record.

but the key object is a record version
I think I’ll just call that a record, and the full history of a record is called record_history or something

DB can give you a vertical version, from which you can get a record
or, DB can give you a history of one student, from which you can get a record

a record can give you:
the history of that record
the version at the point of that record
the version at the next major commit after that record

the main thing you want to access from the DB is the current snapshot / working version

can use a getter to get a student, like working_version[‘id’]
(but I will probably want to add some extra functionality to that getter that is called implicitly)


how to get a field from a record?

I wonder if there is a way to use a function to handle record.field dot syntax
since it needs to replace the underscores in the field name with spaces, and potentially add a period to the end if there are edits
also if I decide to change a field name in the database files, I don’t want to edit that everywhere in the program, so perhaps this function can also be used to replace old names with new names
and if you access a nonexistent field, it will return None

not sure how to deal with fields that have subfields, like names and user data entry


as before, need to keep track of which fields should not be counted in the version control (like notes)

ah I know how to do that
create a JSON file that serves as a template for student records
both for user reference and for the program
the names of the fields can have annotations (* or something) to indicate that they don’t need to be tracked
and if you try to set or access a field that is not there, it will raise an error
this allows for using setattr without accidentally introducing new fields if there is a typo




how to use this between years?
I think just have a settings file that has a path to the folder where it is currently used. The settings.json file for that year must be in the top level of that folder (I think that is a fair requirement)



how is this object interface thing going to work
I don’t want to have to declare a new class for each type of data
Each object has a *template* for what kind of data it represents.

how do lists work?
since that is relevant for concentrations. Need to preserve the template
I think there has to be an object for a list of JSONInterfaces

how to keep track of changes to list elements? add a . to the name of the key that leads to the list
what if you have a list of lists? like in the alphabetization
I guess just change the first one you hit when you go up

also how to keep track of deletions? does there need to be a way to mark that a field was deleted?
I think you can just set the value to null. That’s not something that you would do on purpose
When you commit it, the program handles it and actually deletes the field

now alphabetization doesn’t actually have anything in in that needs to be templated
can just be a list, returned
so in the template, 
…

does it make sense for the template to be on a yearly basis?
since the code relies on the template…
I guess template will in fact go in here
yes this does mean that if the template changes it’s harder to edit last year’s. but why would you ever want to?
oh never mind. just have a git branch for each year. (figure out how to do this and save instructions)



okay
so
how to deal with the database?
need to have a database object, from which we can get records, histories, etc.
major & minor commits?

what if you want to make a branch?
I found that somewhat useful…
do I want to incorporate that ability to the version control system?
basically branching means
you undo your changes to a certain point, and then make other changes from there


there may be the chance that you can sneak around the type system by using the fact that 1 == True etc
but I don’t expect that will be a problem



okay now time to actually figure out how the database works
there should be one file (database.json or something) that stores the working version
(this is what will be put on the page)
the commit command automatically pulls from that file

there needs to be a way to compare two files side by side, I think?

oh it would be nice to have the system be able to focus on just one or a few records
so you don’t have to search, if you don’t want to.
then the history file would have to include stashed changes, so you can change what is in the working version

I think every file other than the history is just like a view into the database.
all necessary information is stored entirely in the database history file
when you save a view into it, it automatically updates the database
use os.stat(path).ST_MTIME
or os.path.getmtime(path)

what is the point of committing, if not to transfer from the working file to the history file?
It saves the state of the DB at that version
And it checks for accidental edits

ok
I think the structure is:
have a tree (maybe DAG, will figure that out later) with branches
right when you commit to a branch, the last version in the branch will be a committed version
but as soon as you start to edit from there, then it creates a new version that is not committed

how does the DB file relate to other files?
as I said before each file outside of it is simply a view into it, an interface to edit it
for each file, need to maintain information about what exactly it represents; what it’s a view into
so that when it’s saved, the program knows how to edit the DB

ooh
can this notion of “views” even extend to only seeing particular fields of particular records?
that might be very useful for e.g. editing organizations
can figure that out later

does there need to be any “core” file that you’re editing? like the most up to date, main version?
which suggests the question: is there a main branch / current branch? or are there just branches and you decide which to use
if the latter
you can just have one file called something like database.json, which anything external (i.e. the layout code) uses
and at any point you can just delete database.json and create a new different view synced to a file with the same name
(or there could even be a built-in way of doing that)
for the most part that makes more sense
however, the only thing I don’t like is that then there is nothing in the DB file itself indicating what is the most up-to-date, correct version — that is only stored through a combination of view parameters and file naming
okay yeah I think I will make you define some branch as the main branch. (you can switch this at any time)
and there is one file that is always just a view of the end of the main branch. you can’t change what it’s looking at, aside from changing what the main branch is. and you can’t delete it. (or if you do, it will be regenerated immediately)

if you want to view anything else (e.g. an old version), you have to create a view

if you want to delete a view, can you just delete the file? or do you have to do it with a command?
I think you can just delete the file. The system will detect it.
what if you change the name of a view?
perhaps each view has an id, stored within the view file and referenced by the DB file
although then the system has to read every json file in the folder
(I guess that’s not such a big problem…)


how should the file be organized?
want it to be as human-readable as possible
Organize by commits. Each commit contains a dictionary with just those records that were updated
actually, to save space, maybe only include the particular *fields* that were updated?
(and then I guess deleting a field would be replacing it with None)
I see no reason not to. It saves space, and I think also time since it doesn’t require writing as much data

If you want to undo a change and have it affect all commits after that, then you can delete that record from the history
okay then that is a case where you want to edit the file

actually
okay
if you have gone to a previous commit and edit it, it will give you two options:
1. create a new branch with your edits and leave the old commit unchanged
2. edit the old commit, and create a new branch with the old version of that commit so it’s saved somewhere
(then you can switch it back if you would like)
then you don’t have to edit the DB history file itself

Each commit has an ID, and potentially a name.
The commit ID should be meaningful
if only one branch, then it can just be 1, 2, 3, 4…
if there are more branches, then there are more numbers that indicate which branch to take at each spot.
like 0.0.2.1#37
meaning: the 37th commit on branch 1 of branch 2 of branch 0 of branch 0
0.0#10 can be followed either by 0.0#11 or by 0.0.0#0, 0.0.1#0, etc.

the whole structure though is a dictionary
so you can easily get to a commit just by getting its id


okay so…
I want to use my interface to edit the database
however, right now the interface keeps track of edits by default. I don’t want that.
I think the better thing to do is to make a separate class that extends dict, which keeps track of edits itself. then mostly that can be ignored in the json interface
hmm that might not really work though?


okay now that I have had that detour
how exactly does the commit structure work? how do you access a specific branch? how do you tell whether the thing at the end is being edited?
oh. I think:
the last thing in a branch is *always* the uncommitted version.
so something is uncommitted iff the next field is empty

do branches need names? It could be nice.
and when you have multiple branches at one point, does one need to be the main branch?
well. it depends on how branches will be used!
A branch is created when you edit an old commit (or create a branch manually)

okay wait. what does this choice actually affect? it’s mainly the id of a commit
no it’s more than that. It also affects how commits are displayed
if you want to swit
nopem!ch to a branch, you need to know what is the point of that branch.
but you can figure that out by looking at the commit messages too…
okay but if you want to have a view onto a branch, you need to give it a name

do we want the ability to insert a new commit between old ones?
no. there is no need for that.

ok. so how do branch names work?
(and branches in general)
I think:
Whenever you make a branch, you’re always branching *off* of some main branch. Rather than splitting into two equal branches.

maybe?
but what if you want to give a name to the “main” at a split

better idea:
it is always just an even fork. and you can name/annotate any/all/none of the sides
the only notion of “main” comes from choosing what the main branch is (?)

however:
you don’t want it to be that, anytime you go back to create a new branch, it removes the name of the branch you had been on.
I think the way it should work is:
each branch has a name. the staring one is called “main” and maybe isn’t changeable? not sure
at a branch point, if a branch has no name, then it takes on the name of what leads into it
(can only have one such branch)

okay I think I know, finally
each commit has a "next" field, which tells you the next commit on the *same* branch
and an optional "branches" field, which tells you of any branches that exist at this point. Those must have names

Must all branches have different names?
well. when do you even need to access a branch by name?
when you are creating a views

I think there should be a dict of branch names to branch IDs, and linking to both the start and the end
actually are there branch ids? I think you just need the id of the start commit (or end)

at this point I also need to decide something else:
does each commit store a backlink to the commit before?
or, otherwise, how do you build up the complete values at a commit?
backlink could be pretty fine. Just use recursion, or work your way back using a loop

the remaining question is whether I want merging to be an option
now I think that storing just the changes that are made in each one makes merging easier, since there are fewer records to compare
but there still could be conflicts. I guess there are a few ways to manage that:
- automatically choose from one or the other
- manually choose for each of them (might require making a new file?)

Okay. I think when you want to merge, you specify which of the two should be the default. (Potentially on a per-attribute basis?) But then it gives you a view where you can make manual changes if you want.
well. I’ll figure that out later.
it will have to compare what changes have happened since the most recent time they each diverged.

annnyway I can do that later. right now I just need the basics to work.

If a branch is merged into another one, that means that that branch can finish entirely and not have an open end.
So you can’t only reference a branch by the end. Sometimes you also need the start.
I think for each branch I will store the start, and the end if there is one
